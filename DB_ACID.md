# transactionとは
  データベース操作を一連の操作としてまとめ、その処理をすべて成功または失敗させることができる。
  ACID特性を保つことを実現することで、一貫性のあるデータベースの状態を実現できる。

##　ACID特性とは
   1. A Atomicity(原子性)
      SQLがすべて成功・失敗することが保証されていること
      1. 処理がすべて成功したら、データベースに処理を反映　→ commit
      2. 処理が一つでも失敗したら、操作を行う最初の状態に戻す　→ rollback

   2. C Consistency(一貫性)
      トランザクション内部の結果に整合性を保つことが保障されていること
      1. 外部キー制約のcascadeやトリガーなどによる値に対しても整合性が保たれる

   3. L Isolatioin(独立性)
      トランザクション処理中の状態はセッション※から独立していることが保障されていること
      ※SQLでDB処理を行うために、セッション・コネクションを取得する(内部処理として)
      1. トランザクション処理中の中身を他のセッション操作では確認することができない

   4. D Durability(永続性)
      1. トランザクション完了後のデータは永続的に保持されることが保障されている

## ロック
   データの更新をする前に、他のセッションから更新をさせないようにすること
   トランザクションを利用した場合は、トランザクション内すべての処理に対してロックを行う
   commit、rollbackを行った時点でロック解除
   1. テーブルロック
   2. 行ロック

## デッドロック
   複数セッションがそれぞれロック解除待ちを行い、処理が完了しない状態
   1. セッション1がテーブル1とテーブル2の処理を行おうとしている
   2. セッション2がテーブル2とテーブル1の処理を行おうとしている
   3. この場合どちらも同じテーブルを処理しようとしているがロックし合っているため、途中で処理がとまる
   この状態になることでパフォーマンスが悪くなる

   ### デッドロック確認方法
   show engine innodb status;
   このクエリを流すことで、デッドロックのログで中身を確認することができる

## truncate　 トランケート
   テーブルの切り捨て
   1. rollbackでも戻すことができない
   2. deleteよりも高速
   3. where句が使用できない
   4. auto_incrementは初期化される

## set システム変数
   データベース上の設定値　データベースの挙動に変化が起きる
   1. システム変数一覧の確認
      1. show [session もしくは　global] variables [like '...' 省略可能];

   2. 値の取得
      1. select @@session.変数名　もしくは　local.変数名　→ 現在のセッション内の値を取得
      2. select @@global.変数名　→ サーバー上の値を取得
      3. select @@変数名　→ sesshonn ~ globalの順番で変数を取得する

   3. 値の変更
      1. set [session もしくは　set local] 変数名 = 値; → 現在のセッションのみで有効
      2. set global 変数名　= 値;　→ サーバー全体(すべてのセッション)で有効(再起動まで有効な飲み)
         そのためset globalは、ほぼ使用しない

## ユーザー定義変数
   変数を利用することができる セッション内のみで使用可能　→ 再起動で再定義が必要
   1. 記述方法
      1. set @変数(命名する) = 値;
      2. @変数(命名する) := 値

## timestampとdatetimeの違い
   1. 使用ストレージの大きさ　timestamp:4byte, datetime:5byte
   2. タイムゾーンの扱い　timestamp:考慮される, datetime:考慮しない
   3. 使用できる期間　timestamp: 〜2038年, datetime:9999年

## create uset ユーザーの確認と作成
   すべての権限を付与されたuser(管理者): root user;
   限定された権限を付与されたuser(開発者): user;
   userを分けることで、知識不足な開発者による致命的なエラーを防ぐことができる

   1. ログイン状態のuserの確認方法
      select user(); → root@localhost((ユーザー名)@(左辺のユーザー名が接続可能なhost名))
   2. user一覧の確認方法
      select * from mysql.user;
   3. ユーザーの作成方法
      create user 'ユーザー名'@'接続元のホスト名' identified by 'password';
      1. 権限の付与の記述方法
         grant 権限名 on 対象のDB名(すべてのDBとする場合 *).テーブル名(すべてのテーブルとする場合 *) to 'ユーザー名';
      2. 付与した権限の確認方法
         show grants for 'test_user'@'localhost';
      3. 権限を削除する記述方法
         revoke 権限名 on 対象のDB名(すべてのDBとする場合 *).テーブル名(すべてのテーブルとする場合 *) from 'ユーザー名';
